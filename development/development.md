---
paths: ~/projects/**
---

# Development Rules

このルールは `~/projects/` 配下のファイルを編集する際に自動適用される。

## Development Environment

環境に合わせて書き換える。

- Node.js: v22.x
- npm: 10.x
- Python: 3.12.x
- Vite: 7.x

### 低スペック環境向けビルド設定
開発機がリソース制約のある環境（8GB RAM等）の場合。

#### Rust
- `.cargo/config.toml` で `jobs = 1` を設定（並列ビルド無効化）
- フル並列だとメモリ不足でハングアップするため必須
- ビルド時間は伸びるが成果物に影響なし

### Project-Specific Guidelines

#### Python
- パッケージ管理: uv（pip直接使用禁止）
- フォーマット: Black (120 columns)
- リント: ruff, mypy, bandit
- テスト: pytest

#### Node.js / TypeScript
- パッケージ管理: npm
- フォーマット: Prettier
- リント: ESLint
- ビルド: Vite

#### React
- 状態管理: 小規模はuseState/useContext、大規模はZustand検討
- スタイリング: Tailwind CSS優先
- コンポーネント: 関数コンポーネント + hooks

#### Android
- 言語: Kotlin優先
- ビルド: Gradle

#### 未知の言語/フレームワーク
上記以外の言語・フレームワークを触る場合:
1. 実装前に一時停止
2. 公式ドキュメント・ベストプラクティスを調査
3. ユーザーと方針確認（使用ツール、コーディング規約等）
4. 確認後に実装開始

### Testing Guidelines

#### 基本方針
- テストは必須（例外なし）
- 新機能: ユニットテスト + 必要に応じて統合テスト
- バグ修正: 再発防止テスト追加
- リファクタリング: 既存テストが通ることを確認
  - テスト変更と実装変更は分離（同時に変更しない）
  - 例外: インターフェース変更、型定義変更、破壊的変更時のみ同時可

#### 見積もり上限（PRサイズ管理）
- 1フェーズ上限: 変更ファイル10個 or 500行 or リスク「高」
- 判断基準: 「レビュアーが1時間で全コード読めるか」
- 超える場合はフェーズ分割

#### テストの粒度
- ユニットテスト: 関数・メソッド単位
- 統合テスト: API・モジュール間連携
- E2Eテスト: 重要フローのみ（コスト高いので絞る）

#### TDD
- 基本適用（テストファースト）
- 実装前にテストケース設計
- Red → Green → Refactor サイクル

#### カバレッジ
- 目標: 95%以上
- 重要なロジック・境界条件は100%カバー

#### コミット前テスト実行方針
- **実装中**: 変更範囲に関連するテストのみ実行（速度優先）
- **コミット前（最終確認）**: 全テスト実行（タイムアウトあり）
- **タイムアウト**: 低スペック環境を考慮し、テストスイート全体で5分超過時は中断+報告
- **失敗時**: コミット不可、実装エージェントに差し戻し

### Git Guidelines

#### 運用ルール
- **新規プロジェクト**: git初期化必須（確認不要、自動で実行）
- **既存プロジェクト**: 変更が入る時にgit導入（既存コードも含めて初期コミット）
- まとまった作業完了時: 「コミットする？」と提案

#### 基本
- コミットメッセージ: 日本語（プロジェクトに合わせて変更可）
- 粒度: 1コミット = 1論理的変更

#### 禁止事項
- .env, credentials, secrets のコミット
- force push（ユーザーの許可なしに）
- 機密情報を含むファイルのプッシュ

#### その他
- 詳細な運用はユーザーと相談して決める
- 不明点があれば都度確認

### Code Review Criteria

#### レビュー観点
- 可読性: 変数名・関数名が意図を表してるか
- 保守性: 将来の変更に耐えられる構造か
- セキュリティ: Security-Guidelines.mdの基準を満たしてるか
- パフォーマンス: 明らかな非効率がないか
- テスト: カバレッジ95%以上、境界条件のテストがあるか

#### 指摘の優先度
- Critical: セキュリティ脆弱性、データ損失リスク → 即修正
- High: バグ、重大な設計問題 → マージ前に修正
- Medium: 可読性、命名 → 修正推奨
- Low: スタイル、好み → 任意

#### セルフレビュー
- PR作成前に自分でチェック
- 「なぜこう書いたか」を説明できるか確認

## Required References
- Primary: @./Coding.md
- Secondary: @./Security-Guidelines.md

## Implementation Agent Instructions

コード実装時は以下のプロセスに従う。安全を最優先に慎重に実装する。

> **ペルソナの適用**:
> エージェントにペルソナ（キャラクター設定）を適用する場合は、
> 別途ペルソナ定義ファイルを `personas/` に配置し、ここで参照する。

### Implementation Process
1. 要件を理解する
2. Coding.md の Universal Principles（10原則）をレビュー
3. ガイドラインに従って実装
4. Pre-Submission Checklist でセルフチェック
5. 実装 + チェックリスト結果を報告

### Key Focus Areas (10 Principles)
1. **Trust Boundary Management**: 全ての外部入力をバリデーション
2. **Defensive Programming**: 明示的な前提条件チェック、フェイルセーフ設計
3. **Strict Resource Management**: 常にコンテキストマネージャーを使用
4. **Comprehensive Error Handling**: 具体的な例外、リトライロジック、グレースフルデグラデーション
5. **Concurrency Safety**: 共有ミュータブル状態を避ける
6. **Time and State Management**: タイムゾーン対応datetime、monotonic clocks
7. **Dependency Verification**: バージョン固定、署名検証
8. **Code Generation Tool Usage**: 生成コードは信頼しない
9. **Logging and Observability**: モジュールレベルロギング、機密データを含めない
10. **Type Safety and Validation**: 型ヒント、境界でのデータバリデーション

### Output Format

#### Implementation Code
```
[Code implementation]
```

#### Pre-Submission Checklist Results
- [ ] Code formatted with Black (120 columns)
- [ ] Module docstring contains all 4 elements (Location, Purpose, Why, Related)
- [ ] Static analysis passed: mypy, ruff, bandit
- [ ] ...
[Complete checklist from Coding.md]

#### Self-Assessment
- **Strengths**: [何がうまく実装できたか]
- **Concerns**: [レビューが必要な箇所]
- **Security Considerations**: [適用したセキュリティ対策]

---

## Security Review Agent Instructions

コードのセキュリティレビュー時は以下のプロセスに従う。攻撃者視点で容赦なく脆弱性を指摘する。

### Review Process
1. 実装コードを読む
2. "Always Apply" 必須項目を全て検証
3. 該当する "Conditional Application" 項目をチェック
4. Security Review Checklist 全体でバリデーション
5. 脆弱性を重大度で分類（Critical/High/Medium/Low）
6. 具体的な修正指示を生成（Lowまで全指摘、漏れなし）

### Always Apply Verification (全プロジェクト必須)
- 全境界での入力バリデーション
- ハードコードされたシークレット/認証情報がないこと
- 具体的な例外ハンドリング（bare exceptなし）
- リソース管理にコンテキストマネージャー使用
- 型ヒントと静的型チェック
- セキュリティスキャン（bandit, ruff）
- 適切なファイルパーミッション（600/700/755）
- 機密データを含まないエラーメッセージ
- セキュリティイベントの監査ログ

### Conditional Application Assessment
プロジェクト特性に応じて適用するセキュリティ対策:
- SQLインジェクション防止（データベース使用時）
- コマンドインジェクション防止（subprocess実行時）
- パストラバーサル防止（ファイルシステム操作時）
- ネットワークセキュリティ/TLS（ネットワーク通信時）
- 認証/認可（マルチユーザー時）
- セッション管理（ステートフル通信時）
- CSRF保護（Webアプリケーション時）
- レート制限（パブリックAPI/エンドポイント時）

### Output Format

#### Critical Issues (即時対応必須)
**Issue**: [説明]
**Location**: [ファイル:行番号]
**Risk**: [セキュリティ影響の説明]
**Remediation**: [具体的な修正指示]

#### High Priority Issues (デプロイ前に修正必須)
[Criticalと同形式]

#### Medium Priority Issues (修正推奨)
[Criticalと同形式]

#### Low Priority Issues (全て対応)
[Criticalと同形式]

#### Security Strengths
- [うまく実装されているセキュリティ対策のリスト]

#### Security Review Checklist Status
- [ ] 全外部入力がホワイトリストアプローチでバリデーション済み
- [ ] ハードコードされた認証情報、APIキー、シークレットがコードにない
- [ ] 全データベース操作でパラメータ化クエリ使用
...
[Security-Guidelines.mdの完全なチェックリスト]

#### Remediation Priority
1. [優先度順の修正リスト]

---

## Specification Management

### 目的
- Compact/セッション跨ぎでも仕様を参照できるようにする
- 開発後の振り返り資産として残す

### 保存場所
- プロジェクトルート直下に `SPEC.md` を作成
- 複数機能がある場合は `specs/` フォルダに分割

### タイミング
- **推奨**: 開発開始前に仕様をfixして保存
- **代替**: 開発完了後に「結局何を作ったか」を記録
- AIから「仕様fixしとく？」と声かける

### テンプレート（軽量版）
```markdown
# [機能名] 仕様書
updated: YYYY-MM-DD

## 目的
なぜこれを作るのか（1-2文）

## 機能
- [ ] 機能1
- [ ] 機能2

## 除外スコープ
- やらないこと

## 技術選定
- 使うライブラリ/フレームワーク

## 備考
- 決定事項、議論の結論など

## セキュリティ検証
- 最終スキャン: YYYY-MM-DD
- 静的解析: bandit 0件 / ruff 0件 / mypy PASS
- セキュリティレビュー: PASS
- 詳細: → Security-Audit.md 参照
```

### Compact対策
- 仕様書が存在すれば、復帰時に参照可能
- ログと併用：ログは経緯、仕様書は結論

---

## Security Report Management

### 目的
- セキュリティレビュー結果を証跡として残す
- 「堅牢である」の客観的根拠を提供する
- 全指摘事項（Lowまで）の対応状況を追跡する

### 保存場所
- プロジェクトルート直下に `Security-Audit.md`
- SPEC.mdにはセキュリティ検証の概要のみ記載（詳細はSecurity-Audit.md参照）

### 更新タイミング
- セキュリティレビュー完了時に更新（必須）
- 指摘事項の修正完了時に対応状況を更新

### テンプレート
```markdown
# Security Report
updated: YYYY-MM-DD

## 最新レビュー結果
- 日付: YYYY-MM-DD
- 判定: PASS / CONDITIONAL / REJECT
- 静的解析: bandit 0件 / ruff 0件 / mypy PASS

## 指摘履歴

### YYYY-MM-DD レビュー
#### Critical
- なし

#### High
- なし

#### Medium
- [指摘内容] → 対応済み (YYYY-MM-DD)

#### Low
- [指摘内容] → 対応済み (YYYY-MM-DD)

## 適用済みセキュリティ対策
- [このプロジェクトで適用した対策一覧]

## Conditional Application 判定
- [適用/非適用の判定とその理由]
```

---

## README Management

### 目的
- リポジトリを開いて3秒で「何のプロジェクトか」を理解できるようにする
- 技術的ドキュメント（GLOSSARY/SPEC）にたどり着くまでの入口として機能させる

### 方針
- **エレベーターピッチ式**: 冒頭3行で「何を・なぜ・どう」を完結させる
- **対象読者**: 非技術者を含む

### テンプレート
```markdown
# [プロジェクト名]

[何を] [なぜ] [どう解決するか]（3行以内）

## 技術スタック
- 言語/フレームワーク
- 主要ライブラリ

## セットアップ
（必要なら最小限の手順）

## 関連ドキュメント
- [GLOSSARY.md](./GLOSSARY.md) - コード内の主要な変数・関数・hookの役割一覧
- [SPEC.md](./SPEC.md) - 機能仕様
```

### ルール
- 冒頭3行に専門用語を使わない（使う場合はカッコ内に平易な説明）
- 技術詳細はGLOSSARY/SPECに委譲、READMEには書かない

---

## Glossary Management

### 目的
- コード内の主要な変数・関数・hookの役割を一覧化
- 修正時の参照、説明時のカンペとして使用

### 保存場所
- プロジェクトルート直下に `GLOSSARY.md`

### テンプレート
```markdown
# Glossary
updated: YYYY-MM-DD

## 変数・State
| 名前 | 種別 | 役割 |
|------|------|------|
| `userSession` | state | ログイン中ユーザーのセッション情報 |

## 関数・Hooks
| 名前 | 種別 | 役割 |
|------|------|------|
| `fetchProducts` | 関数 | 商品一覧をAPIから取得 |
| `useCart` | hook | カート状態の管理 |

## 型・Interface
| 名前 | 役割 |
|------|------|
| `Product` | 商品データの型定義 |
```

### 更新タイミング
- 実装完了時に自動生成/更新
- 対象: exportされた変数・関数・hook・型

---

## Development Workflow

### 役割分担（厳守）

| 役割 | 担当 | 責任 |
|------|------|------|
| 実装 | 実装エージェント | コード実装、セルフチェック |
| セキュリティレビュー | レビューエージェント | 脆弱性検出、修正指示 |
| 最終評価・報告 | メインAI | 品質判断、ユーザーへの報告 |
| 意思決定 | ユーザー | 承認・方針決定 |

> **エージェント分離の意図**:
> 実装者がレビューを兼ねると客観性が損なわれる。
> 別エージェント（サブプロセス）に分離することで、独立した視点を確保する。
> また、実装エージェントには軽量モデル（sonnet等）を使い、トークンコストを抑える。

### タスク判断フロー

標準フローに入る前に、タスクの複雑さを判断する。

#### 直接実行（標準フローへ）
- 要件が明確
- 類似実装の経験あり
- 影響範囲が限定的

#### PlanMode経由
- 複数のアーキテクチャ選択肢がある
- 既存コードの調査が必要
- 「どう作るか」の設計判断が先に必要

**フロー**: EnterPlanMode → 探索・設計 → プラン提示 → ExitPlanMode → ユーザー承認 → 標準フローへ

### 確認ツールの使い分け

| 状況 | ツール |
|------|--------|
| 「AとBどっち？」の選択 | AskUserQuestion |
| 「どう作る？」の設計 | PlanMode |
| 承認確認（Y/N） | AskUserQuestion |
| フェーズ間の確認 | AskUserQuestion |

### コーディング委譲ルール（必須）

**メインAIは実装コードを直接書かない。**

- 「簡単だから」「ちょっとした修正だから」という理由での例外なし
- 1行の修正でも実装エージェントに委譲
- メインAIが直接触るのはログ・設定ファイル・ドキュメントのみ

理由：
- 役割の明確化（評価者が実装者を兼ねると客観性が損なわれる）
- 一貫したコード品質（実装エージェントのチェックリストを必ず通す）
- トークン効率（実装エージェントはsonnet、メインAIはopus）

### 標準フロー

```
ユーザー: 要件提示
    ↓
メインAI: 要件整理・実装エージェントに委譲
    ↓
実装エージェント: 実装 + セルフチェック + テスト（変更範囲） → メインAIに報告
    ↓
メインAI: レビューエージェントに委譲（必須・全実装対象・例外なし）
    ↓
レビューエージェント: セキュリティレビュー（全指摘Low含む） → メインAIに報告
    ↓
[指摘あり] 実装エージェントに差し戻し → 修正 → レビューエージェント再レビュー
    ↓
[指摘なし] メインAI: 最終評価 + 全テスト実行（タイムアウトあり）
    ↓
メインAI: ユーザーに報告 + Security-Audit.md更新
    ↓
ユーザー: 承認 → コミット
```

### コミットルール（厳守）

- **実装/レビューエージェント未通過のコミット禁止**（例外なし）
- コミット順序: 実装完了 → レビューPASS → テスト全通過 → コミット
- レビューがREJECTした状態でのコミットは絶対禁止
- このルールはAI経由の開発が前提（ユーザーが直接git操作する場合を除く）

### ファイル削除の運用

開発中に発生する不要ファイル（デバッグ用、一時ファイル等）の処理。

#### 運用ルール
| 操作 | コマンド | 確認 |
|------|----------|------|
| 不要ファイル移動 | `mv /path/to/file ~/.claude-trash/` | なし |
| 後片付け（ユーザーが実行） | `rm -rf ~/.claude-trash/*` | ユーザーが直接実行 |
| 中身確認 | `ls ~/.claude-trash/` | なし |

#### タイミング
- 開発中: 不要ファイルはゴミ箱に移動
- 動作確認完了後: ユーザーが後片付けとしてまとめて削除

---

## Evaluator Instructions (メインAI)

実装エージェント・レビューエージェントからの成果物を受け取り、最終評価を行う。

### 評価観点

#### 品質基準
- [ ] 要件を満たしているか
- [ ] Coding.md/Security-Guidelines.mdの基準に準拠しているか
- [ ] 実装エージェントのセルフチェックが適切か
- [ ] レビューエージェントの指摘事項が解消されているか

#### ユーザー視点の判断
- [ ] ユーザーが求めていたものか（要件の解釈ズレがないか）
- [ ] 過剰実装になっていないか
- [ ] 説明がユーザーに伝わるレベルか

#### 判定
- **PASS**: ユーザーに報告OK
- **CONDITIONAL**: 軽微な修正後にPASS（実装エージェントに差し戻し）
- **REJECT**: 要件再確認 or 大幅修正必要（ユーザーに相談）

### 報告フォーマット

```
## 実装完了報告

### 概要
[何を実装したか、1-2文]

### 成果物
- [ファイル:行番号] 変更内容

### 評価結果
- 品質: [OK/要確認]
- セキュリティ: [レビュー判定結果]
- 所感: [気になる点があれば]

### 次のアクション
[ユーザーに求めること：確認、承認、追加指示など]
```

### 注意事項
- 評価者は実装しない（上記「コーディング委譲ルール」参照）
- 判断に迷ったらユーザーに確認
- レビューエージェントがREJECTした場合、メインAI独断でPASSにしない
